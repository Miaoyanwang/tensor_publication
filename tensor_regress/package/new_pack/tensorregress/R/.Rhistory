(p7|p8)
dev.off()
# standarlized
X = c(rep(1,10), rep(0,10))
X_s<-sweep(X,2,apply(X,2,mean),"-")
# standarlized
X = cbind(c(rep(1,10), rep(0,10)), c(rep(0,10), rep(1,10)))
X_s<-sweep(X,2,apply(X,2,mean),"-")
X_s
# standarlized
X = cbind(c(rep(1,10), rep(0,10),rep(0,10)), c(rep(0,10), rep(1,10), rep(0,10)))
X_s<-sweep(X,2,apply(X,2,mean),"-")
X_s
X = cbind(c(rep(1,10), rep(0,10),rep(-1,10)), c(rep(0,10), rep(1,10), rep(-1,10)))
X_s<-sweep(X,2,apply(X,2,mean),"-")
X_s
X_s<-sweep(X,2,apply(X_s,2,sd),"/")
X_s
# standarlized
X = cbind(c(rep(1,10), rep(0,10),rep(0,10)), c(rep(0,10), rep(1,10), rep(0,10)))
X_s<-sweep(X,2,apply(X,2,mean),"-")
X_s<-sweep(X,2,apply(X_s,2,sd),"/")
X_s
# standarlized
X = cbind(c(rep(1,10), rep(0,10),rep(0,10)), c(rep(0,10), rep(1,10), rep(0,10)))
X_s<-sweep(X,2,apply(X,2,mean),"-")
X_s<-sweep(X_s,2,apply(X_s,2,sd),"/")
X_s
X = cbind(c(rep(1,10), rep(0,10),rep(-1,10)), c(rep(0,10), rep(1,10), rep(-1,10)))
X_s<-sweep(X,2,apply(X,2,mean),"-")
X_s<-sweep(X_s,2,apply(X_s,2,sd),"/")
X_s
signal_range=c(3,6)
core_range=rbind(c(3,3,3),c(4,5,6))
##
dup=10;
d=20;
whole_shape = rep(d,3);
final_mode=array(0,dim=c(2,2,3,2)) # ours vs mreg
final_sd_mode=array(0,dim=c(2,2,3,2))
err_res=err_mreg=array(0,dim=c(2,2,3,dup))
dist="binary";
s = 1; r = 1; i = 1; n = 1;
core_shape=core_range[r,]
signal=signal_range[s]
cat("signal = ",signal, ", rank = ", core_shape, ", info number = ",i,", dup = ", n,"\n" )
if(i==1){ ## one mode covaraite
data=sim_data(whole_shape = whole_shape, core_shape=core_shape,p=c(0,0,0.4*d),dist=dist, dup=dup, signal=signal)
res = tensor_regress(data$tsr[[n]],X_covar3 = data$X_covar3,core_shape=core_shape,Nsim=10, cons = 'non', dist = dist)### tensor_regress
}else if(i==2){ ## two mode covaraite
data=sim_data(whole_shape = whole_shape, core_shape=core_shape,p=c(0,0.4*d,0.4*d),dist=dist, dup=dup, signal=signal)
res = tensor_regress(data$tsr[[n]],X_covar2 = data$X_covar2,X_covar3 = data$X_covar3,core_shape=core_shape,Nsim=10, cons = 'non', dist = dist)### tensor_regress
}else if (i==3){## three model covariate
data=sim_data(whole_shape = whole_shape, core_shape=core_shape,p=c(0.4*d,0.4*d,0.4*d),dist=dist, dup=dup, signal=signal)
res = tensor_regress(data$tsr[[n]],X_covar1 = data$X_covar1,X_covar2 = data$X_covar2,X_covar3 = data$X_covar3,core_shape=core_shape,Nsim=10, cons = 'non', dist = dist)### tensor_regress
}
mean((res$U - data$U)^2)
mreg_res = best_SymGLM(as.tensor(data$tsr[[n]]),data$X_covar3)$result # result with best rank and sparsity
# calculate the prediction
Theta = mreg_res$A%*%diag(mreg_res$w)%*%t(mreg_res$A)
mreg_B = ttm(mreg_res$BB,data$X_covar3,m = 3)@data
mreg_U = mreg_B
for (k in 1:dim(mreg_B)[3]) {
mreg_U[,,k] = mreg_B[,,k] + Theta
}
mean((mreg_U - data$U)^2)
s = 1; r = 1; i = 1; n = 1;
core_shape=core_range[r,]
signal=signal_range[s]
cat("signal = ",signal, ", rank = ", core_shape, ", info number = ",i,", dup = ", n,"\n" )
if(i==1){ ## one mode covaraite
data=sim_data(whole_shape = whole_shape, core_shape=core_shape,p=c(0,0,0.4*d),dist=dist, dup=dup, signal=signal)
res = tensor_regress(data$tsr[[n]],X_covar3 = data$X_covar3,core_shape=core_shape,Nsim=10, cons = 'non', dist = dist)### tensor_regress
}else if(i==2){ ## two mode covaraite
data=sim_data(whole_shape = whole_shape, core_shape=core_shape,p=c(0,0.4*d,0.4*d),dist=dist, dup=dup, signal=signal)
res = tensor_regress(data$tsr[[n]],X_covar2 = data$X_covar2,X_covar3 = data$X_covar3,core_shape=core_shape,Nsim=10, cons = 'non', dist = dist)### tensor_regress
}else if (i==3){## three model covariate
data=sim_data(whole_shape = whole_shape, core_shape=core_shape,p=c(0.4*d,0.4*d,0.4*d),dist=dist, dup=dup, signal=signal)
res = tensor_regress(data$tsr[[n]],X_covar1 = data$X_covar1,X_covar2 = data$X_covar2,X_covar3 = data$X_covar3,core_shape=core_shape,Nsim=10, cons = 'non', dist = dist)### tensor_regress
}
mreg_res = best_SymGLM(as.tensor(data$tsr[[n]]),data$X_covar3)$result # result with best rank and sparsity
# calculate the prediction
Theta = mreg_res$A%*%diag(mreg_res$w)%*%t(mreg_res$A)
mreg_B = ttm(mreg_res$BB,data$X_covar3,m = 3)@data
mreg_U = mreg_B
for (k in 1:dim(mreg_B)[3]) {
mreg_U[,,k] = mreg_B[,,k] + Theta
}
mean((mreg_U - data$U)^2)
mean((res$U - data$U)^2)
library("rTensor")
## Mreg code
source("netglm_code_adjust.R") # original data has a typo in the output of best_SymGLM()
library(tensorregress)
set.seed(0)
seed=0
## combinations of signal and rank
signal_range=c(3,6)
core_range=rbind(c(3,3,3),c(4,5,6))
##
dup=10;
d=20;
whole_shape = rep(d,3);
final_mode=array(0,dim=c(2,2,3,2)) # ours vs mreg
final_sd_mode=array(0,dim=c(2,2,3,2))
err_res=err_mreg=array(0,dim=c(2,2,3,dup))
dist="binary";
s = 1; r = 1; i = 1; n = 1;
core_shape=core_range[r,]
signal=signal_range[s]
cat("signal = ",signal, ", rank = ", core_shape, ", info number = ",i,", dup = ", n,"\n" )
if(i==1){ ## one mode covaraite
data=sim_data(whole_shape = whole_shape, core_shape=core_shape,p=c(0,0,0.4*d),dist=dist, dup=dup, signal=signal)
res = tensor_regress(data$tsr[[n]],X_covar3 = data$X_covar3,core_shape=core_shape,Nsim=10, cons = 'non', dist = dist)### tensor_regress
}else if(i==2){ ## two mode covaraite
data=sim_data(whole_shape = whole_shape, core_shape=core_shape,p=c(0,0.4*d,0.4*d),dist=dist, dup=dup, signal=signal)
res = tensor_regress(data$tsr[[n]],X_covar2 = data$X_covar2,X_covar3 = data$X_covar3,core_shape=core_shape,Nsim=10, cons = 'non', dist = dist)### tensor_regress
}else if (i==3){## three model covariate
data=sim_data(whole_shape = whole_shape, core_shape=core_shape,p=c(0.4*d,0.4*d,0.4*d),dist=dist, dup=dup, signal=signal)
res = tensor_regress(data$tsr[[n]],X_covar1 = data$X_covar1,X_covar2 = data$X_covar2,X_covar3 = data$X_covar3,core_shape=core_shape,Nsim=10, cons = 'non', dist = dist)### tensor_regress
}
mean((res$U - data$U)^2)
mreg_res = best_SymGLM(as.tensor(data$tsr[[n]]),data$X_covar3)$result # result with best rank and sparsity
# calculate the prediction
Theta = mreg_res$A%*%diag(mreg_res$w)%*%t(mreg_res$A)
mreg_B = ttm(mreg_res$BB,data$X_covar3,m = 3)@data
mreg_U = mreg_B
for (k in 1:dim(mreg_B)[3]) {
mreg_U[,,k] = mreg_B[,,k] + Theta
}
mean((mreg_U - data$U)^2)
plot(vec(data$U), vec(res$U))
plot(as.vector(data$U), as.vector(res$U))
plot(as.vector(data$U), as.vector(mreg_U))
cor((res$U - data$U)^2)
#err_res[s,r,i,n]= mean((res$U - data$U)^2)
err_res[s,r,i,n]= cor(res$U, data$U)
cor(res$U, data$U)
plot(as.vector(data$U), as.vector(res$U))
cor(mreg_U, data$U)
library("rTensor")
## Mreg code
source("netglm_code_adjust.R") # original data has a typo in the output of best_SymGLM()
library(tensorregress)
###### run simulation. PMSE vs. number of informative modes
set.seed(0)
seed=0
## combinations of signal and rank
signal_range=c(3,6)
core_range=rbind(c(3,3,3),c(4,5,6))
##
dup=5;
d=20;
whole_shape = rep(d,3);
final_mode=array(0,dim=c(2,2,3,2)) # ours vs mreg
final_sd_mode=array(0,dim=c(2,2,3,2))
err_res=err_mreg=array(0,dim=c(2,2,3,dup))
dist="binary";
for(s in 1){ ## signal level
for(r in 1:2){ ## rank
for(i in 1:3){ ## number of informative covariates
for(n in 1:dup){ ## simulation replicates
core_shape=core_range[r,]
signal=signal_range[s]
cat("signal = ",signal, ", rank = ", core_shape, ", info number = ",i,", dup = ", n,"\n" )
if(i==1){ ## one mode covaraite
data=sim_data(whole_shape = whole_shape, core_shape=core_shape,p=c(0,0,0.4*d),dist=dist, dup=dup, signal=signal)
res = tensor_regress(data$tsr[[n]],X_covar3 = data$X_covar3,core_shape=core_shape,Nsim=10, cons = 'non', dist = dist)### tensor_regress
}else if(i==2){ ## two mode covaraite
data=sim_data(whole_shape = whole_shape, core_shape=core_shape,p=c(0,0.4*d,0.4*d),dist=dist, dup=dup, signal=signal)
res = tensor_regress(data$tsr[[n]],X_covar2 = data$X_covar2,X_covar3 = data$X_covar3,core_shape=core_shape,Nsim=10, cons = 'non', dist = dist)### tensor_regress
}else if (i==3){## three model covariate
data=sim_data(whole_shape = whole_shape, core_shape=core_shape,p=c(0.4*d,0.4*d,0.4*d),dist=dist, dup=dup, signal=signal)
res = tensor_regress(data$tsr[[n]],X_covar1 = data$X_covar1,X_covar2 = data$X_covar2,X_covar3 = data$X_covar3,core_shape=core_shape,Nsim=10, cons = 'non', dist = dist)### tensor_regress
}
#err_res[s,r,i,n]= mean((res$U - data$U)^2)
err_res[s,r,i,n]= cor(res$U, data$U)
plot(as.vector(data$U), as.vector(res$U))
mreg_res = best_SymGLM(as.tensor(data$tsr[[n]]),data$X_covar3)$result # result with best rank and sparsity
# calculate the prediction
Theta = mreg_res$A%*%diag(mreg_res$w)%*%t(mreg_res$A)
mreg_B = ttm(mreg_res$BB,data$X_covar3,m = 3)@data
mreg_U = mreg_B
for (k in 1:dim(mreg_B)[3]) {
mreg_U[,,k] = mreg_B[,,k] + Theta
}
#err_mreg[s,r,i,n] = mean((mreg_U - data$U)^2)
err_mreg[s,r,i,n] = cor(mreg_U, data$U)
plot(as.vector(data$U), as.vector(mreg_U))
}
final_mode[s,r,i,1]=mean(err_res[s,r,i,])
final_mode[s,r,i,2]=mean(err_mreg[s,r,i,])
final_sd_mode[s,r,i,1]=sd(err_res[s,r,i,])
final_sd_mode[s,r,i,2]=sd(err_mreg[s,r,i,])
}
}
}
final = final_mode
finalsd = final_sd_mode
library(ggplot2)
library(patchwork)
new_color = c("#069AA0","#CCC591")
signal_range=c(3,6)
core_range=rbind(c(3,3,3),c(4,5,6))
s=1;r=1;
data=data.frame(PMSE=c(final[s,r,1,],final[s,r,2,],final[s,r,3,])/signal_range[s],sd=c(finalsd[s,r,1,],finalsd[s,r,2,],finalsd[s,r,3,])/signal_range[s],Method=rep(c('STD (Our method)',"Mreg"),3),Category=c(rep(1,2),rep(2,2),rep(3,2)))
data[,3]=factor(data[,3],levels=c("STD (Our method)","Mreg"))
p1=ggplot(data=data, aes(x=as.factor(Category),y=PMSE, fill=Method))+geom_bar(stat="identity", position=position_dodge())+geom_errorbar(aes(ymin=PMSE-sd, ymax=PMSE+sd), width=.2,position=position_dodge(.9))+labs(x="Number of modes with available features",y="MSPE")+coord_cartesian(ylim = c(0, 0.75)) +  labs(title = "Low Signal, Low Rank",size = 5) +theme(plot.title = element_text(hjust = 0.5,size = 11))+
scale_fill_manual(values=new_color)+theme(axis.text=element_text(size=12),axis.title=element_text(size=10))
p1
s=1;r=2;
data=data.frame(PMSE=c(final[s,r,1,],final[s,r,2,],final[s,r,3,])/signal_range[s],sd=c(finalsd[s,r,1,],finalsd[s,r,2,],finalsd[s,r,3,])/signal_range[s],Method=rep(c('STD (Our method)',"Mreg"),3),Category=c(rep(1,2),rep(2,2),rep(3,2)))
data[,3]=factor(data[,3],levels=c("STD (Our method)","Mreg"))
p2=ggplot(data=data, aes(x=as.factor(Category),y=PMSE, fill=Method))+geom_bar(stat="identity", position=position_dodge())+geom_errorbar(aes(ymin=PMSE-sd, ymax=PMSE+sd), width=.2,position=position_dodge(.9))+labs(x="Number of modes with available features",y="MSPE")+coord_cartesian(ylim = c(0, 0.75)) +  labs(title = "Low Signal, High Rank",size = 5) +theme(plot.title = element_text(hjust = 0.5,size = 11))+
scale_fill_manual(values=new_color)+theme(axis.text=element_text(size=12),axis.title=element_text(size=10))
p2
a = matrix(1:4,nrow = 2, ncol = 2)
1 - a
final = 1 - final_mode
finalsd = final_sd_mode
s=1;r=1;
data=data.frame(PMSE=c(final[s,r,1,],final[s,r,2,],final[s,r,3,])/signal_range[s],sd=c(finalsd[s,r,1,],finalsd[s,r,2,],finalsd[s,r,3,])/signal_range[s],Method=rep(c('STD (Our method)',"Mreg"),3),Category=c(rep(1,2),rep(2,2),rep(3,2)))
data[,3]=factor(data[,3],levels=c("STD (Our method)","Mreg"))
p1=ggplot(data=data, aes(x=as.factor(Category),y=PMSE, fill=Method))+geom_bar(stat="identity", position=position_dodge())+geom_errorbar(aes(ymin=PMSE-sd, ymax=PMSE+sd), width=.2,position=position_dodge(.9))+labs(x="Number of modes with available features",y="MSPE")+coord_cartesian(ylim = c(0, 0.75)) +  labs(title = "Low Signal, Low Rank",size = 5) +theme(plot.title = element_text(hjust = 0.5,size = 11))+
scale_fill_manual(values=new_color)+theme(axis.text=element_text(size=12),axis.title=element_text(size=10))
p1
s=1;r=2;
data=data.frame(PMSE=c(final[s,r,1,],final[s,r,2,],final[s,r,3,])/signal_range[s],sd=c(finalsd[s,r,1,],finalsd[s,r,2,],finalsd[s,r,3,])/signal_range[s],Method=rep(c('STD (Our method)',"Mreg"),3),Category=c(rep(1,2),rep(2,2),rep(3,2)))
data[,3]=factor(data[,3],levels=c("STD (Our method)","Mreg"))
p2=ggplot(data=data, aes(x=as.factor(Category),y=PMSE, fill=Method))+geom_bar(stat="identity", position=position_dodge())+geom_errorbar(aes(ymin=PMSE-sd, ymax=PMSE+sd), width=.2,position=position_dodge(.9))+labs(x="Number of modes with available features",y="MSPE")+coord_cartesian(ylim = c(0, 0.75)) +  labs(title = "Low Signal, High Rank",size = 5) +theme(plot.title = element_text(hjust = 0.5,size = 11))+
scale_fill_manual(values=new_color)+theme(axis.text=element_text(size=12),axis.title=element_text(size=10))
p2
s=1;r=1;
data=data.frame(PMSE=c(final[s,r,1,],final[s,r,2,],final[s,r,3,])/signal_range[s],sd=c(finalsd[s,r,1,],finalsd[s,r,2,],finalsd[s,r,3,])/signal_range[s],Method=rep(c('STD (Our method)',"Mreg"),3),Category=c(rep(1,2),rep(2,2),rep(3,2)))
data[,3]=factor(data[,3],levels=c("STD (Our method)","Mreg"))
p1=ggplot(data=data, aes(x=as.factor(Category),y=PMSE, fill=Method))+geom_bar(stat="identity", position=position_dodge())+geom_errorbar(aes(ymin=PMSE-sd, ymax=PMSE+sd), width=.2,position=position_dodge(.9))+labs(x="Number of modes with available features",y="1 - Correlation")+coord_cartesian(ylim = c(0, 0.5)) +  labs(title = "Low Signal, Low Rank",size = 5) +theme(plot.title = element_text(hjust = 0.5,size = 11))+
scale_fill_manual(values=new_color)+theme(axis.text=element_text(size=12),axis.title=element_text(size=10))
p1
s=1;r=2;
data=data.frame(PMSE=c(final[s,r,1,],final[s,r,2,],final[s,r,3,])/signal_range[s],sd=c(finalsd[s,r,1,],finalsd[s,r,2,],finalsd[s,r,3,])/signal_range[s],Method=rep(c('STD (Our method)',"Mreg"),3),Category=c(rep(1,2),rep(2,2),rep(3,2)))
data[,3]=factor(data[,3],levels=c("STD (Our method)","Mreg"))
p2=ggplot(data=data, aes(x=as.factor(Category),y=PMSE, fill=Method))+geom_bar(stat="identity", position=position_dodge())+geom_errorbar(aes(ymin=PMSE-sd, ymax=PMSE+sd), width=.2,position=position_dodge(.9))+labs(x="Number of modes with available features",y="1 - Correlation")+coord_cartesian(ylim = c(0, 0.5)) +  labs(title = "Low Signal, High Rank",size = 5) +theme(plot.title = element_text(hjust = 0.5,size = 11))+
scale_fill_manual(values=new_color)+theme(axis.text=element_text(size=12),axis.title=element_text(size=10))
p2
pdf("Mreg_cor_mode.pdf", width = 10, height = 3)
(p1|p2)
dev.off()
save(final_mode, final_sd_mode,file = "Mreg_cor_mode.RData")
s = 1; r = 1; i = 1; n =1;
core_shape=core_range[r,]
signal=signal_range[s]
cat("signal = ",signal, ", rank = ", core_shape, ", info number = ",i,", dup = ", n,"\n" )
if(i==1){ ## one mode covaraite
data=sim_data(whole_shape = whole_shape, core_shape=core_shape,p=c(0,0,0.4*d),dist=dist, dup=dup, signal=signal)
res = tensor_regress(data$tsr[[n]],X_covar3 = data$X_covar3,core_shape=core_shape,Nsim=10, cons = 'non', dist = dist)### tensor_regress
}else if(i==2){ ## two mode covaraite
data=sim_data(whole_shape = whole_shape, core_shape=core_shape,p=c(0,0.4*d,0.4*d),dist=dist, dup=dup, signal=signal)
res = tensor_regress(data$tsr[[n]],X_covar2 = data$X_covar2,X_covar3 = data$X_covar3,core_shape=core_shape,Nsim=10, cons = 'non', dist = dist)### tensor_regress
}else if (i==3){## three model covariate
data=sim_data(whole_shape = whole_shape, core_shape=core_shape,p=c(0.4*d,0.4*d,0.4*d),dist=dist, dup=dup, signal=signal)
res = tensor_regress(data$tsr[[n]],X_covar1 = data$X_covar1,X_covar2 = data$X_covar2,X_covar3 = data$X_covar3,core_shape=core_shape,Nsim=10, cons = 'non', dist = dist)### tensor_regress
}
plot(as.vector(data$U), as.vector(res$U))
cor(res$U, data$U)
s = 1; r = 1; i = 1; n =1;
core_shape=core_range[r,]
signal=signal_range[s]
cat("signal = ",signal, ", rank = ", core_shape, ", info number = ",i,", dup = ", n,"\n" )
if(i==1){ ## one mode covaraite
data=sim_data(whole_shape = whole_shape, core_shape=core_shape,p=c(0,0,0.4*d),dist=dist, dup=dup, signal=signal)
res = tensor_regress(data$tsr[[n]],X_covar3 = data$X_covar3,core_shape=core_shape,Nsim=10, cons = 'non', dist = dist)### tensor_regress
}else if(i==2){ ## two mode covaraite
data=sim_data(whole_shape = whole_shape, core_shape=core_shape,p=c(0,0.4*d,0.4*d),dist=dist, dup=dup, signal=signal)
res = tensor_regress(data$tsr[[n]],X_covar2 = data$X_covar2,X_covar3 = data$X_covar3,core_shape=core_shape,Nsim=10, cons = 'non', dist = dist)### tensor_regress
}else if (i==3){## three model covariate
data=sim_data(whole_shape = whole_shape, core_shape=core_shape,p=c(0.4*d,0.4*d,0.4*d),dist=dist, dup=dup, signal=signal)
res = tensor_regress(data$tsr[[n]],X_covar1 = data$X_covar1,X_covar2 = data$X_covar2,X_covar3 = data$X_covar3,core_shape=core_shape,Nsim=10, cons = 'non', dist = dist)### tensor_regress
}
cor(res$U, data$U)
plot(as.vector(data$U), as.vector(res$U))
cat("signal = ",signal, ", rank = ", core_shape, ", info number = ",i,", dup = ", n,"\n" )
mreg_res = mySymGLM(as.tensor(data$tsr[[n]]),data$X_covar3, R =2, sparsity = 20*20*8,niter=50)
# calculate the prediction
Theta = mreg_res$A%*%diag(mreg_res$w)%*%t(mreg_res$A)
mreg_B = ttm(mreg_res$BB,data$X_covar3,m = 3)@data
mreg_U = mreg_B
for (k in 1:dim(mreg_B)[3]) {
mreg_U[,,k] = mreg_B[,,k] + Theta
}
plot(as.vector(data$U), as.vector(mreg_U))
cor(mreg_U, data$U)
data=sim_data(whole_shape = c(20,20,20), core_shape=c(3,3,3),p=c(0,0,8),dist="binary", dup=1, signal=3)
res = tensor_regress(data$tsr[[n]],X_covar3 = data$X_covar3,core_shape=c(3,3,3),Nsim=10, cons = 'non', dist="binary", )### tensor_regress
mreg_res = mySymGLM(as.tensor(data$tsr[[n]]),data$X_covar3, R =2, sparsity = 20*20*8,niter=50)
# calculate the prediction
Theta = mreg_res$A%*%diag(mreg_res$w)%*%t(mreg_res$A)
mreg_B = ttm(mreg_res$BB,data$X_covar3,m = 3)@data
mreg_U = mreg_B
for (k in 1:dim(mreg_B)[3]) {
mreg_U[,,k] = mreg_B[,,k] + Theta
}
plot(as.vector(data$U), as.vector(mreg_U))
mreg_res = mySymGLM(as.tensor(data$tsr[[n]]),data$X_covar3, R =2, sparsity = 20*20*8*0.1,niter=50)
# calculate the prediction
Theta = mreg_res$A%*%diag(mreg_res$w)%*%t(mreg_res$A)
mreg_B = ttm(mreg_res$BB,data$X_covar3,m = 3)@data
mreg_U = mreg_B
for (k in 1:dim(mreg_B)[3]) {
mreg_U[,,k] = mreg_B[,,k] + Theta
}
plot(as.vector(data$U), as.vector(mreg_U))
mreg_res = mySymGLM(as.tensor(data$tsr[[n]]),data$X_covar3, R =2, sparsity = 20*20*8*0.5,niter=50)
# calculate the prediction
Theta = mreg_res$A%*%diag(mreg_res$w)%*%t(mreg_res$A)
mreg_B = ttm(mreg_res$BB,data$X_covar3,m = 3)@data
mreg_U = mreg_B
for (k in 1:dim(mreg_B)[3]) {
mreg_U[,,k] = mreg_B[,,k] + Theta
}
plot(as.vector(data$U), as.vector(mreg_U))
pdf("santiy_check.pdf", width = 10, height = 10)
dev.off()
par(mfrow = c(2,2))
plot(as.vector(data$U), as.vector(res$U), xlab = "ground truth", ylab = "Mreg estimate",main = "STD")
alpha = 1
mreg_res = mySymGLM(as.tensor(data$tsr[[n]]),data$X_covar3, R =2, sparsity = 20*20*8*alpha,niter=50)
# calculate the prediction
Theta = mreg_res$A%*%diag(mreg_res$w)%*%t(mreg_res$A)
mreg_B = ttm(mreg_res$BB,data$X_covar3,m = 3)@data
mreg_U = mreg_B
for (k in 1:dim(mreg_B)[3]) {
mreg_U[,,k] = mreg_B[,,k] + Theta
}
#### sanity check ####
set.seed(1810)
set.seed(1810)
data=sim_data(whole_shape = c(20,20,20), core_shape=c(3,3,3),p=c(0,0,8),dist="binary", dup=1, signal=3)
res = tensor_regress(data$tsr[[n]],X_covar3 = data$X_covar3,core_shape=c(3,3,3),Nsim=10, cons = 'non', dist="binary", )### tensor_regress
alpha = 1
mreg_res = mySymGLM(as.tensor(data$tsr[[n]]),data$X_covar3, R =2, sparsity = 20*20*8*alpha,niter=50)
# calculate the prediction
Theta = mreg_res$A%*%diag(mreg_res$w)%*%t(mreg_res$A)
mreg_B = ttm(mreg_res$BB,data$X_covar3,m = 3)@data
mreg_U = mreg_B
for (k in 1:dim(mreg_B)[3]) {
mreg_U[,,k] = mreg_B[,,k] + Theta
}
par(mfrow = c(2,2))
plot(as.vector(data$U), as.vector(res$U), xlab = "ground truth", ylab = "Mreg estimate",main = paste0('STD, cor = ', cor(res$U, data$U)," PMSE = ", mean((res$U - data$U)^2) ))
par(mfrow = c(2,2))
plot(as.vector(data$U), as.vector(res$U), xlab = "ground truth", ylab = "STD estimate",main = paste0('STD, cor = ', round(cor(res$U, data$U),digits = 2)," PMSE = ", round(mean((res$U - data$U)^2) ,digits = 2)))
plot(as.vector(data$U), as.vector(mreg_U), xlab = "ground truth", ylab = "Mreg estimate", main = paste0("Mreg, alpha = ", alpha ,"cor = ",round(cor(mreg_U, data$U),digits = 2)," PMSE = ", round(mean((mreg_U - data$U)^2) ,digits = 2)))
alpha = 0.5
mreg_res = mySymGLM(as.tensor(data$tsr[[n]]),data$X_covar3, R =2, sparsity = 20*20*8*alpha,niter=50)
# calculate the prediction
Theta = mreg_res$A%*%diag(mreg_res$w)%*%t(mreg_res$A)
mreg_B = ttm(mreg_res$BB,data$X_covar3,m = 3)@data
mreg_U = mreg_B
for (k in 1:dim(mreg_B)[3]) {
mreg_U[,,k] = mreg_B[,,k] + Theta
}
plot(as.vector(data$U), as.vector(mreg_U), xlab = "ground truth", ylab = "Mreg estimate", main = paste0("Mreg, alpha = ", alpha ,"cor = ",round(cor(mreg_U, data$U),digits = 2)," PMSE = ", round(mean((mreg_U - data$U)^2) ,digits = 2)))
alpha = 0.1
mreg_res = mySymGLM(as.tensor(data$tsr[[n]]),data$X_covar3, R =2, sparsity = 20*20*8*alpha,niter=50)
# calculate the prediction
Theta = mreg_res$A%*%diag(mreg_res$w)%*%t(mreg_res$A)
mreg_B = ttm(mreg_res$BB,data$X_covar3,m = 3)@data
mreg_U = mreg_B
for (k in 1:dim(mreg_B)[3]) {
mreg_U[,,k] = mreg_B[,,k] + Theta
}
plot(as.vector(data$U), as.vector(mreg_U), xlab = "ground truth", ylab = "Mreg estimate", main = paste0("Mreg, alpha = ", alpha ,"cor = ",round(cor(mreg_U, data$U),digits = 2)," PMSE = ", round(mean((mreg_U - data$U)^2) ,digits = 2)))
## gender case ##
X1 = c(rep(1,5), rep(0,5)); X2 = c(rep(0,5),rep(1,5))
n<-10L
p<-1
N<-10L
s<-0.1
R<-2
# generate data
A<-matrix(rnorm(n*R),nrow=n,ncol=R)
m<-A%*%t(A)
true_Theta<-as.tensor(m%o%rep(1,N))
plot(true_Theta@data[,,2], col=brewer.pal(n = 10, name = "RdBu"), breaks = seq(-10,10,2))
###### Mreg vs STD comparison (Invariance)######
library(plot.matrix)
library(RColorBrewer)
# generate data
A<-matrix(rnorm(n*R),nrow=n,ncol=R)
m<-A%*%t(A)
true_Theta<-as.tensor(m%o%rep(1,N))
plot(true_Theta@data[,,2], col=brewer.pal(n = 10, name = "RdBu"), breaks = seq(-10,10,2))
par(mfrow = c(1,1))
plot(true_Theta@data[,,2], col=brewer.pal(n = 10, name = "RdBu"), breaks = seq(-10,10,2))
# generate data
A<-matrix(rnorm(n*R),nrow=n,ncol=R)
m<-A%*%t(A)
true_Theta<-as.tensor(m%o%rep(1,N))
plot(true_Theta@data[,,2], col=brewer.pal(n = 10, name = "RdBu"), breaks = seq(-10,10,2))
BB = array(0,dim = c(n,n,p))
for(i in 1:p){
slice_vec<-rep(0,n*(n-1)/2)
slice_vec[sample(c(1:(n*(n-1)/2)),n*n*s/2)]<-2
slice<-matrix(0,n,n)
slice[upper.tri(slice)]<-slice_vec
slice<-slice+t(slice)
BB[,,i] = slice
}
BB = as.tensor(BB)
sum(BB@data!= 0)
plot(BB@data,col=brewer.pal(n = 10, name = "RdBu"), breaks = seq(-10,10,2))
dim(BB@data)
plot(BB@data[,,1],col=brewer.pal(n = 10, name = "RdBu"), breaks = seq(-10,10,2))
#Z<-generateTensor(N,n,X,true_Theta,BB)
Z <- generateTensor_normal(N,n,X,true_Theta,BB)
#Z<-generateTensor(N,n,X,true_Theta,BB)
Z <- generateTensor_normal(N,n,X1,true_Theta,BB)
#Z<-generateTensor(N,n,X,true_Theta,BB)
Z <- generateTensor(N,n,X1,true_Theta,BB)
## gender case ##
X1 = as.matrix(c(rep(1,5), rep(0,5))); X2 = c(rep(0,5),rep(1,5))
#Z<-generateTensor(N,n,X,true_Theta,BB)
Z <- generateTensor(N,n,X1,true_Theta,BB)
## gender case ##
X1 = as.matrix(c(rep(1,5), rep(0,5))); X2 = as.matrix(c(rep(0,5),rep(1,5)))
true_U = (true_Theta+ttm(BB,X1,m = 3))@data
plot(true_U[,,1],col=brewer.pal(n = 10, name = "RdBu"), breaks = seq(-10,10,2))
plot(true_U[,,6],col=brewer.pal(n = 10, name = "RdBu"), breaks = seq(-10,10,2))
plot(true_Theta@data[,,2], col=brewer.pal(n = 10, name = "RdBu"), breaks = seq(-10,10,2))
# with encoding 1
mreg_res = mySymGLM_normal(Z, X1,  R = R, sparsity= n*n*p*s, niter=50)
Theta = mreg_res$A%*%diag(mreg_res$w)%*%t(mreg_res$A)
plot(Theta,col=brewer.pal(n = 10, name = "RdBu"), breaks = seq(-10,10,2))
mreg_B = ttm(mreg_res$BB,X,m = 3)@data
mreg_B = ttm(mreg_res$BB,X1,m = 3)@data
mreg_U = mreg_B
for (k in 1:dim(mreg_B)[3]) {
mreg_U[,,k] = mreg_B[,,k] + Theta
}
plot(mreg_U[,,1],col=brewer.pal(n = 10, name = "RdBu"), breaks = seq(-10,10,2))
# with encoding 1
mreg_res = mySymGLM(Z, X1,  R = R, sparsity= n*n*p*s, niter=50)
Theta = mreg_res$A%*%diag(mreg_res$w)%*%t(mreg_res$A)
plot(Theta,col=brewer.pal(n = 10, name = "RdBu"), breaks = seq(-10,10,2))
mreg_B = ttm(mreg_res$BB,X1,m = 3)@data
mreg_U = mreg_B
for (k in 1:dim(mreg_B)[3]) {
mreg_U[,,k] = mreg_B[,,k] + Theta
}
plot(mreg_U[,,1],col=brewer.pal(n = 10, name = "RdBu"), breaks = seq(-10,10,2))
plot(mreg_U[,,6],col=brewer.pal(n = 10, name = "RdBu"), breaks = seq(-10,10,2))
library(rTensor)
library(rTensor)
library(tensorregress)
install_version("TRES", "1.1.3")
library(remotes)
install_version("TRES", "1.1.3")
library(TRES)
install.packages("ManifoldOptim")
install.packages("Rcpp")
install.packages("RcppArmadillo")
install_version("TRES", "1.1.3")
library(remotes)
install_version("TRES", "1.1.3")
library(rTensor)
install_version("rTensor", "1.4")
library(rTensor)
install_version("TRES", "1.1.3")
library(rTensor)
library(TRES)
remove.packages("rTensor")
install_version("rTensor", "1.4")
library(TRES)
library(tensorregress)
whole_shape = c(20,20,20)
core_shape = c(3,3,3)
data = sim_data(whole_shape = whole_shape, core_shape = core_shape, p = c(0,0,5),dist = "normal", dup = 2, signal = 3)
res = tensor_regress(data$tsr[[1]], X_covar3 = data$X_covar3, core_shape =  core_shape, niter = 10, cons = "non", dist = "normal", initial = "QR_tucker")
M1 = res$W$W3
t(M1)%*%M1
res1 = tensor_regress(data$tsr[[1]], X_covar3 = data$X_covar3, core_shape =  core_shape, niter = 10, cons = "non", dist = "normal", initial = "QR_tucker",change = T)
M1 = res1$W$W3
t(M1)%*%M1
M1 = res1$W$W2
t(M1)%*%M1
M1 = res1$W$W1
t(M1)%*%M1
identical(res$U, res1$U)
identical(res$C_ts, res1$C_ts)
mean((res$C_ts - res1$C_ts)^2)
mean((res$U -  res1$U)^2)
res$lglk
res1$lglk
data = sim_data(whole_shape = whole_shape, core_shape = core_shape, p = c(0,0,5),dist = "binary", dup = 2, signal = 3)
res = tensor_regress(data$tsr[[1]], X_covar3 = data$X_covar3, core_shape =  core_shape, niter = 10, cons = "non", dist = "normal", initial = "QR_tucker")
M1 = res$W$W3
t(M1)%*%M1
res1 = tensor_regress(data$tsr[[1]], X_covar3 = data$X_covar3, core_shape =  core_shape, niter = 10, cons = "non", dist = "normal", initial = "QR_tucker",change = T)
M1 = res1$W$W1
t(M1)%*%M1
setwd("/Users/March/Documents/GitHub/research_Jiaxin/tensor_regress/package/new_pack/tensorregress/R")
library(devtools)
build()
remove.packages("tensorregress")
install.packages("/Users/March/Documents/GitHub/research_Jiaxin/tensor_regress/package/new_pack/tensorregress_4.0.tar.gz", repos = NULL, type="source")
library(tensorregress)
whole_shape = c(20,20,20)
core_shape = c(3,3,3)
data = sim_data(whole_shape = whole_shape, core_shape = core_shape, p = c(0,0,5),dist = "binary", dup = 2, signal = 3)
res = tensor_regress(data$tsr[[1]], X_covar3 = data$X_covar3, core_shape =  core_shape, niter = 10, cons = "non", dist = "normal", initial = "QR_tucker")
M1 = res$W$W3
t(M1)%*%M1
