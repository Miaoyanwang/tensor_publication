% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tensor_clustering.R
\name{sim_hDCBM_network}
\alias{sim_hDCBM_network}
\title{Simulation of degree-corrected tensor block models}
\usage{
sim_hDCBM_network(
  seed = NA,
  p,
  r,
  delta,
  s_min,
  s_max,
  dist = c("normal", "binary"),
  sigma = 1,
  theta_dist = c("abs_normal", "pareto", "non"),
  alpha = NULL,
  beta = NULL,
  imat = F
)
}
\arguments{
\item{seed}{number, random seed for generating data}

\item{p}{integer, dimension of the tensor observation}

\item{r}{integer, number of clusters on each mode}

\item{delta}{number, Frobenius norm of the slices in core tensor; see "details"}

\item{s_min}{number, value of off-diagonal elements in core tensor}

\item{s_max}{number, value of diagonal elements in core tensor}

\item{dist}{character, distribution of tensor observation; see "details"}

\item{sigma}{number, standard deviation of Gaussian noise if \code{dist = "normal"}; see "details"}

\item{theta_dist}{character, distribution of degree heterogeneity; see "details"}

\item{alpha}{number, shape parameter in pareto distribution if \code{theta_dist = "pareto"}}

\item{beta}{number, scale parameter in pareto distribution if \code{theta_dist = "pareto"}}

\item{imat}{logic variable, if "TRUE", generate matrix data; if "FALSE", generate order-3 tensor data}
}
\value{
a list containing the following:

\code{Y} {array ( if \code{imat = F} ) or matrix ( if \code{imat = T} ), simulated tensor or matrix observations with dimension \code{p} on each mode  }

\code{X} {array ( if \code{imat = F} ) or matrix ( if \code{imat = T} ), mean tensor or matrix of the observation, i.e., the expectation of \code{Y}}

\code{S} {symmetric array ( if \code{imat = F} ) or matrix ( if \code{imat = T} ), core tensor or matrix recording the block effects with dimension \code{r} on each mode}

\code{theta} {vector, degree heterogeneity for \code{p} entities on each mode}

\code{z} {vector, clustering assignment for \code{p} entities on each mode}
}
\description{
Generate symmetric order-3 tensor or matrix data with degree heterogeneity under degree-corrected tensor block models.
}
\details{
The tensor observation is generated as
\code{Y = S x1 Theta M x2 Theta M x3 Theta M + E,}
where \code{S} is the core tensor, \code{Theta} is a diagonal matrix with elements \code{theta},
\code{M} is the membership matrix based on the clustering assignment \code{z}, \code{E} is the noise tensor, and \code{xk} refers to the matrix-by-tensor product on the \code{k}-th mode.

If \code{imat = T}, \code{Y,S,E} degenerate to matrix and we have \code{Y = Theta M S M^T Theta^T + E}.

The core tensor \code{S} is firstly a diagonal tensor or matrix with diagonal elements \code{s_max} and off-diagonal elements \code{s_min}.
Then, we control the Frobenius norm of the slices in \code{S} with parameter \code{delta} as
\code{S} = \code{S}*\code{delta}/\code{delta_min}, where \code{delta_min = sqrt(sum(S[1,,]^2))} ( if \code{imat = F} ) or \code{delta_min = sqrt(sum(S[1,]^2))} ( if \code{imat = T} ).

\code{dist} specifies the distribution of \code{E}: "normal" for Gaussian and "binary" for Bernoulli distribution; \code{sigma} specifices the standard deviation if \code{dist = "normal"}.

\code{theta_dist} firstly specifies the distribution of \code{theta}: "non" for constant 1, "abs_normal" for absoulte normal distribution, "pareto" for pareto distribution; \code{alpha, beta} specify the shape and scale parameter if \code{theta_dist = "pareto"}.
Then, \code{theta} is scaled to have mean equal to one in each cluster.
}
\examples{
seed = 1
p = 30
r = 3
delta = 0.5
s_min = 0.05
s_max = 1
dist = "normal"
theta_dist = "pareto"
alpha = 4
beta = 3/4
sigma = 0.2

data = sim_hDCBM_network(seed = seed, p, r,  delta = delta,
 s_min = s_min, s_max = s_max, dist =  dist, sigma = sigma,
 theta_dist = theta_dist, alpha = alpha, beta = beta, imat = F)

}
